# visualizer.py
import tkinter as tk
from tkinter import ttk
import time  

class MazeApp:
    def __init__(self, generate_maze_func, bfs_func, dfs_func, dijkstra_func, astar_func):
        self.generate_maze_func = generate_maze_func # a 2D List, Path = 0, Wall = 1. This is our generate maze.
        self.algorithms = {'BFS': bfs_func, 'DFS': dfs_func, 'Dijkstra': dijkstra_func, 'A*': astar_func} # a dictionary of algorithms, each key is the name of the algorithm and the value is the function that implements it.
        self.algorithm_name = 'BFS' # this is the default algorithm choice in the combobox.

        self.maze = [] #initially empty maze, it will be generated by the generate_maze_func.
        self.path = [] #initially empty path, it will be filled by the algorithm when it finds a path.
        self.cell_size = 10 # size of each square cell in the maze.

        # Initialize the main window
        self.root = tk.Tk()
        self.root.title("Maze Solver")
        self.root.geometry("600x500")
        #self.root.resizable(False, False)

        self.canvas = tk.Canvas(self.root)# creates a smaller window for the maze, inside the root window.
        self.canvas.pack() # default position for adding the maze, it will be at the top of the window.

        self.controls = tk.Frame(self.root) #a small window for the buttons and combobox, inside the root window.
        self.controls.pack() # will be placed by default under the canva.

        self.gen_btn = tk.Button(self.controls, text="Generate Maze", command=self.generate_maze)
        self.gen_btn.pack(side=tk.LEFT, padx=5)

        self.algo_menu = ttk.Combobox(self.controls, values=list(self.algorithms.keys())) # a list is made with the keys of the algorithms dictionary ['BFS', 'DFS', 'Dijkstra', 'A*']
        self.algo_menu.current(0) # sets the default value to the first item in the list, which is 'BFS'.
        self.algo_menu.pack(side=tk.LEFT, padx=5)
        self.algo_menu.bind("<<ComboboxSelected>>", self.select_algorithm) # calls select_algorithm when the user selects an algorithm from the combobox.

        self.solve_btn = tk.Button(self.controls, text="Solve", command=self.solve_maze) # calls solve_maze.
        self.solve_btn.pack(side=tk.LEFT, padx=5)

    def run(self):
        self.root.mainloop() # starts the main loop of the tkinter application.

    def select_algorithm(self, event): # event is used to satisfy tkinter everytime an action is performed on the combobox.
        self.algorithm_name = self.algo_menu.get()

    def generate_maze(self): # generates and draws a new maze and resets the path
        self.maze = self.generate_maze_func()
        self.path = []
        self.draw_maze()

    def solve_maze(self):
        if not self.maze: # does nothing if the maze is empty to prevent crash.
            return
        start = (0, 1) # maze entrance is at (0, 1) (top-left inside). (y,x) 
        end = (len(self.maze) - 1, len(self.maze[0]) - 2) # maze exit (bottom-right inside). since python uses 0-based indexing, we subtract 1 from the height and width of the maze to get the correct coordinates.
        algo = self.algorithms[self.algorithm_name] # gets the algorithm function from the dictionary using the selected algorithm name.

        t0 = time.time()
        self.path = algo(self.maze, start, end) # calls the algorithm function.
        t1 = time.time()

        print(f"{self.algorithm_name} path length: {len(self.path)}") # prints the length of the path found by the algorithm.
        print(f"{self.algorithm_name} time taken: {(t1 - t0)*1000:.2f} ms") # prints the time taken by the algorithm to find the path in milliseconds.

        self.draw_maze()

    def draw_maze(self):
        self.canvas.delete("all") # this deletes whatever was in canvas (aka our maze).
        rows, cols = len(self.maze), len(self.maze[0]) # gets the number of rows and columns in the maze.
        cell = self.cell_size # represents the size of each cell in the maze.
        self.canvas.config(width=cols * cell, height=rows * cell) # resizes the canvas to fit the maze exactly.

        # Draw base grid using the maze generated.
        for y in range(rows):
            for x in range(cols):
                color = "black" if self.maze[y][x] == 1 else "white"

                # x1,y1 is the top-left corner of the rectangle, x2,y2 is the bottom-right corner of the rectangle.
                self.canvas.create_rectangle(
                    x * cell, y * cell,
                    (x + 1) * cell, (y + 1) * cell,
                    fill=color, outline="gray"
                )

        # loop through the path tuple list and starts drawing green rectangles for each cell in the path.
        for y, x in self.path:
            self.canvas.create_rectangle(
                x * cell, y * cell,
                (x + 1) * cell, (y + 1) * cell,
                fill="green"
            )

        # hard coded coordinates for the start and end of the maze.
        # Start (top-left inside). 
        self.canvas.create_rectangle(
            1 * cell, 0,
            2 * cell, 1 * cell,
            fill="red"
        )

        # End (bottom-right inside)
        self.canvas.create_rectangle(
            (cols - 2) * cell, (rows - 1) * cell,
            (cols - 1) * cell, rows * cell,
            fill="red"
        )
